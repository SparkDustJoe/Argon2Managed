#pragma once

/*
* Adapted from the reference code implementation
*   Copyright 2017 Dustin J Sparks
*   Using CC0 1.0 license, this code is released under the same.
* ===========================================================================
* Argon2 reference source code package - reference C implementations
*
* Copyright 2015
* Daniel Dinu, Dmitry Khovratovich, Jean-Philippe Aumasson, and Samuel Neves
*
* You may use this work under the terms of a Creative Commons CC0 1.0
* License/Waiver or the Apache Public License 2.0, at your option. The terms of
* these licenses can be found at:
*
* - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
* - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
*
* You should have received a copy of both of these licenses along with this
* software. If not, they may be obtained at the above URLs.
*/

//#include "Argon2Thread.h"  //WARNING!! MULTI THREAD CODE NOT WORKING!! MISSING REFERENCES

using namespace System;

#define ARGON2_VERSION_10		0x10
#define ARGON2_VERSION_13		0x13
#define ARGON2_VERSION_NUMBER	ARGON2_VERSION_13

#define T_COST_DEF		3
#define M_COST_DEF		4096 /* 2^12 = 4 MiB */
#define LANES_DEF		1
#define THREADS_DEF		1
#define OUTLEN_DEF		32
//#define MAX_PASS_LEN	128

#define ARGON2_BLOCK_SIZE				1024
#define ARGON2_QWORDS_IN_BLOCK			(ARGON2_BLOCK_SIZE / 8)
#define ARGON2_OWORDS_IN_BLOCK			(ARGON2_BLOCK_SIZE / 16)
#define ARGON2_HWORDS_IN_BLOCK			(ARGON2_BLOCK_SIZE / 32)
#define ARGON2_512BIT_WORDS_IN_BLOCK	(ARGON2_BLOCK_SIZE / 64)

/* Number of pseudo-random values generated by one call to Blake in Argon2i
to generate reference block positions */
#define ARGON2_ADDRESSES_IN_BLOCK		128

/* Pre-hashing digest length and its extension*/
#define ARGON2_PREHASH_DIGEST_LENGTH	64
#define ARGON2_PREHASH_SEED_LENGTH		72
/* Minimum and maximum number of lanes (degree of parallelism) */
#define ARGON2_MIN_LANES 1UL
#define ARGON2_MAX_LANES 0xFFFFFFUL

/* Minimum and maximum number of threads */
#define ARGON2_MIN_THREADS 1UL
#define ARGON2_MAX_THREADS 0xFFFFFFUL

/* Number of synchronization points between lanes per pass */
#define ARGON2_SYNC_POINTS 4UL

/* Minimum and maximum digest size in bytes */
#define ARGON2_MIN_OUTLEN 4UL
#define ARGON2_MAX_OUTLEN 0xFFFFFFFFUL

/* Minimum and maximum number of memory blocks (each of BLOCK_SIZE bytes) */
#define ARGON2_MIN_MEMORY (2 * ARGON2_SYNC_POINTS) /* 2 blocks per slice */

#define ARGON2_MIN(a, b) ((a) < (b) ? (a) : (b))
/* Max memory size is addressing-space/2, topping at 2^32 blocks (4 TB) */
#define ARGON2_MAX_MEMORY_BITS                                                 \
    ARGON2_MIN(32UL, (sizeof(array<Byte>^) * 8 - 10 - 1))
#define ARGON2_MAX_MEMORY      0xFFFFFFFFUL //                                                \
//    ARGON2_MIN(0xFFFFFFFFUL, 1UL << ARGON2_MAX_MEMORY_BITS)

/* Minimum and maximum number of passes */
#define ARGON2_MIN_TIME 1UL
#define ARGON2_MAX_TIME 0xFFFFFFFFUL

/* Minimum and maximum password length in bytes */
#define ARGON2_MIN_PWD_LENGTH 0
#define ARGON2_MAX_PWD_LENGTH 0xFFFFFFFFUL

/* Minimum and maximum associated data length in bytes */
#define ARGON2_MIN_AD_LENGTH 0
#define ARGON2_MAX_AD_LENGTH 0xFFFFFFFFUL

/* Minimum and maximum salt length in bytes */
#define ARGON2_MIN_SALT_LENGTH 8UL
#define ARGON2_MAX_SALT_LENGTH 0xFFFFFFFFUL

/* Minimum and maximum key length in bytes */
#define ARGON2_MIN_SECRET 0
#define ARGON2_MAX_SECRET 0xFFFFFFFFUL

/* Flags to determine which fields are securely wiped (default = wipe all). */
#define ARGON2_DEFAULT_FLAGS 3
#define ARGON2_FLAG_CLEAR_PASSWORD 1UL
#define ARGON2_FLAG_CLEAR_SECRET 2UL

namespace Argon2Managed
{
	/*
	* Structure for the (1KB) memory block implemented as 128 64-bit words.
	* Memory blocks can be copied, XORed. Internal words can be accessed by [] (no
	* bounds checking).
	*/
	typedef ref struct block_
	{
		array<UInt64>^ v = gcnew array<UInt64>(ARGON2_QWORDS_IN_BLOCK);
	} block;

	public enum class Argon2Type : System::Byte
	{
		d = 0,
		i = 1, //default
		id = 2
	}; //*/
	ref struct Context
	{
		array<Byte>^	out;    /* output array */
		UInt32			outlen; /* digest length */
		array<Byte>^	pwd;    /* password array */
		//UInt32			pwdlen; /* password length */
		array<Byte>^	salt;    /* salt array */
		//UInt32			saltlen; /* salt length */
		array<Byte>^	secret;    /* key array */
		//UInt32			secretlen; /* key length */
		array<Byte>^	ad;    /* associated data array */
		//UInt32			adlen; /* associated data length */
		UInt32			t_cost;  /* number of passes */
		UInt32			m_cost;  /* amount of memory requested (KB) */
		UInt32			lanes;   /* number of lanes */
		UInt32			threads; /* maximum number of threads */
		UInt32			version; /* version number */
		UInt32			flags; /* array of bool options */
		Argon2Type		type;
	};
	ref struct Instance
	{
		array<block^>^	memory;        /* Memory pointer */
		UInt32			passes;        /* Number of passes */
		UInt32			memory_blocks; /* Number of blocks in memory */
		UInt32			segment_length;
		UInt32			lane_length;
		UInt32			lanes;
		UInt32			threads;
		int				print_internals; /* whether to print the memory blocks */
		Context^		context_ptr; /* points back to original context */
	};
	ref struct Position
	{
		UInt32			pass;
		UInt32			lane;
		UInt32			slice;
		UInt32			index;
	};
	ref struct ThreadData
	{
		Instance^		i;
		Position^		p;
	};

	/*************************Argon2 core functions********************************/

	static void __inline copy_block(block^ dst, const block^ src) {
		Buffer::BlockCopy(src->v, 0, dst->v, 0, ARGON2_BLOCK_SIZE);
	}

	static void __inline xor_block(block^ dst, const block^ src) {
		for (int i = 0; i < ARGON2_QWORDS_IN_BLOCK; ++i) {
			dst->v[i] ^= src->v[i];
		}
	}

	static void __inline load_block(block^ dst, array<const Byte>^ input) {
		Buffer::BlockCopy(input, 0, dst->v, 0, sizeof(dst));
	}

	static void __inline store_block(array<Byte>^ output, const block^ src) {
		Buffer::BlockCopy(src->v, 0, output, 0, sizeof(src->v));
	}

	static void __inline store_block(array<Byte>^ output, array<const UInt64>^ src) {
		Buffer::BlockCopy(src, 0, output, 0, sizeof(src));
	}

	/* Function that securely cleans the memory. This ignores any flags set
	* regarding clearing memory. Usually one just calls clear_internal_memory.
	* @param mem Pointer to the memory
	* These are likely defined in the underlying Blake2 headers
	*/
#ifndef METHOD_SECURE_WIPE_BYTES
#define METHOD_SECURE_WIPE_BYTES
	static void secure_wipe_memory(array<Byte>^ data)
	{
		if (data == nullptr) return;
#if !_DEBUG
		try {
#endif
			Byte lm = 0;
			for (int i = 0; i < data->Length; i++)
			{
				data[i] &= lm ^ data[i] ^ data[i];
			}
			data[0] ^= data[data->Length - 1];
#if !_DEBUG
		}
		catch (...) {}
#endif
	}
#endif // secure_wipe_bytes

#ifndef METHOD_SECURE_WIPE_QWORDS
#define METHOD_SECURE_WIPE_QWORDS
	static void secure_wipe_memory(array<UInt64>^ data)
	{
		if (data == nullptr) return;
#if !_DEBUG
		try {
#endif
			Byte lm = 0;
			for (int i = 0; i < data->Length * sizeof(UInt64); i++)
			{
				Buffer::SetByte(data, i, lm & (Byte)data[0]);
			}
			data[0] ^= data[data->Length - 1];
#if !_DEBUG
		}
		catch (...) {}
#endif
	}
#endif // secure_wipe_qwords

	/*
	* Zero's memory at the given pointer 
	*/
	static void free_memory(array<Byte>^ memory)
	{
		if (memory == nullptr) return;
		try { secure_wipe_memory(memory); }
		catch (...) {}
	}
	static void free_memory(array<UInt64>^ memory)
	{
		if (memory == nullptr) return;
		try { secure_wipe_memory(memory); }
		catch (...) {}
	}
	static void free_memory(array<block^>^ memory)
	{
		if (memory == nullptr) return;
		for (int i = 0; i < memory->Length; i++)
		{
			secure_wipe_memory(memory[i]->v);
		}
	}

	/*
	* Computes absolute position of reference block in the lane following a skewed
	* distribution and using a pseudo-random value as input
	* @param instance Pointer to the current instance
	* @param position Pointer to the current position
	* @param pseudo_rand 32-bit pseudo-random value used to determine the position
	* @param same_lane Indicates if the block will be taken from the current lane.
	* If so we can reference the current segment
	* @pre All pointers must be valid
	*/
	static UInt32 index_alpha(const Instance^ instance,
		const Position^ position, UInt32 pseudo_rand,
		int same_lane)
	{    /*
		 * Pass 0:
		 *      This lane : all already finished segments plus already constructed
		 * blocks in this segment
		 *      Other lanes : all already finished segments
		 * Pass 1+:
		 *      This lane : (SYNC_POINTS - 1) last segments plus already constructed
		 * blocks in this segment
		 *      Other lanes : (SYNC_POINTS - 1) last segments
		 */
		UInt32 reference_area_size;
		UInt64 relative_position;
		UInt32 start_position, absolute_position;

		if (0 == position->pass) {
			/* First pass */
			if (0 == position->slice) {
				/* First slice */
				reference_area_size =
					position->index - 1; /* all but the previous */
			}
			else {
				if (same_lane) {
					/* The same lane => add current segment */
					reference_area_size =
						position->slice * instance->segment_length +
						position->index - 1;
				}
				else {
					reference_area_size =
						position->slice * instance->segment_length +
						((position->index == 0) ? (-1) : 0);
				}
			}
		}
		else {
			/* Second pass */
			if (same_lane) {
				reference_area_size = instance->lane_length -
					instance->segment_length + position->index -
					1;
			}
			else {
				reference_area_size = instance->lane_length -
					instance->segment_length +
					((position->index == 0) ? (-1) : 0);
			}
		}

		/* 1.2.4. Mapping pseudo_rand to 0..<reference_area_size-1> and produce
		* relative position */
		relative_position = pseudo_rand;
		relative_position = relative_position * relative_position >> 32;
		relative_position = reference_area_size - 1 -
			(reference_area_size * relative_position >> 32);

		/* 1.2.5 Computing starting position */
		start_position = 0;

		if (0 != position->pass) {
			start_position = (position->slice == ARGON2_SYNC_POINTS - 1)
				? 0
				: (position->slice + 1) * instance->segment_length;
		}

		/* 1.2.6. Computing absolute position */
		absolute_position = (start_position + relative_position) %
			instance->lane_length; /* absolute position */
		return absolute_position;
	}

	/*
	* Function that validates all inputs against predefined restrictions and return
	* an error code
	* @param context Pointer to current Argon2 context
	* @return ARGON2_OK if everything is all right, otherwise one of error codes
	* (all defined in <argon2.h>
	*/
	static int validate_inputs(const Context^ context)
	{
		if (nullptr == context) {
			return ARGON2_INCORRECT_PARAMETER;
		}

		if (nullptr == context->out) {
			return ARGON2_OUTPUT_PTR_NULL;
		}

		// Validate output length
		if (ARGON2_MIN_OUTLEN > context->outlen) {
			return ARGON2_OUTPUT_TOO_SHORT;
		}

		if (ARGON2_MAX_OUTLEN < context->outlen) {
			return ARGON2_OUTPUT_TOO_LONG;
		}

		// Validate Password (required param)
		if (context->pwd == nullptr) {
			return ARGON2_PWD_PTR_MISMATCH;
		}

		if (ARGON2_MIN_PWD_LENGTH > context->pwd->Length) {
			return ARGON2_PWD_TOO_SHORT;
		}

		if (ARGON2_MAX_PWD_LENGTH < context->pwd->Length) {
			return ARGON2_PWD_TOO_LONG;
		}

		// Validate Salt (required param)
		if (context->salt == nullptr) {
			return ARGON2_SALT_PTR_MISMATCH;
		}

		if (ARGON2_MIN_SALT_LENGTH > context->salt->Length) {
			return ARGON2_SALT_TOO_SHORT;
		}

		if (ARGON2_MAX_SALT_LENGTH < context->salt->Length) {
			return ARGON2_SALT_TOO_LONG;
		}


		// Validate Secret
		if (context->secret != nullptr && ARGON2_MIN_SECRET > context->secret->Length) {
			return ARGON2_SECRET_TOO_SHORT;
		}
		if (context->secret != nullptr && ARGON2_MAX_SECRET < context->secret->Length) {
			return ARGON2_SECRET_TOO_LONG;
		}

		// Validate Additional Data
		if (context->ad != nullptr && ARGON2_MIN_AD_LENGTH > context->ad->Length) {
			return ARGON2_AD_TOO_SHORT;
		}
		if (context->ad != nullptr && ARGON2_MAX_AD_LENGTH < context->ad->Length) {
			return ARGON2_AD_TOO_LONG;
		}

		// Validate memory cost 
		if (ARGON2_MIN_MEMORY > context->m_cost) {
			return ARGON2_MEMORY_TOO_LITTLE;
		}

		if (ARGON2_MAX_MEMORY < context->m_cost) {
			return ARGON2_MEMORY_TOO_MUCH;
		}

		if (context->m_cost < 8 * context->lanes) {
			return ARGON2_MEMORY_TOO_LITTLE;
		}

		// Validate time cost
		if (ARGON2_MIN_TIME > context->t_cost) {
			return ARGON2_TIME_TOO_SMALL;
		}

		if (ARGON2_MAX_TIME < context->t_cost) {
			return ARGON2_TIME_TOO_LARGE;
		}

		// Validate lanes
		if (ARGON2_MIN_LANES > context->lanes) {
			return ARGON2_LANES_TOO_FEW;
		}

		if (ARGON2_MAX_LANES < context->lanes) {
			return ARGON2_LANES_TOO_MANY;
		}

		// Validate threads
		if (ARGON2_MIN_THREADS > context->threads) {
			return ARGON2_THREADS_TOO_FEW;
		}

		if (ARGON2_MAX_THREADS < context->threads) {
			return ARGON2_THREADS_TOO_MANY;
		}

		return ARGON2_OK;
	}

	static array<Byte>^ blake2b_long(UInt32 length, array<const Byte>^ src)
	{
		array<Byte>^ output = gcnew array<Byte>(length);
		Blake2bState^ blake_state;
		array<Byte>^ outlen_bytes = BitConverter::GetBytes(length);

		if (length <= BLAKE2B_OUTBYTES) {
			blake_state = Argon2Managed::Blake2b::blake2b_init(nullptr, nullptr, nullptr, length);
			Argon2Managed::Blake2b::blake2b_update(blake_state, (array<const Byte>^)outlen_bytes);
			Argon2Managed::Blake2b::blake2b_update(blake_state, src);
			output = Argon2Managed::Blake2b::blake2b_final(blake_state);
		}
		else {
			Blake2b^ b = gcnew Blake2b();
			int outptr = 0;
			UInt32 toproduce = length - BLAKE2B_OUTBYTES / 2;
			array<Byte>^ out_buffer = gcnew array<Byte>(BLAKE2B_OUTBYTES);
			array<Byte>^ in_buffer = gcnew  array<Byte>(BLAKE2B_OUTBYTES);
			blake_state = Argon2Managed::Blake2b::blake2b_init(nullptr, nullptr, nullptr, BLAKE2B_OUTBYTES);
			Argon2Managed::Blake2b::blake2b_update(blake_state, (array<const Byte>^)outlen_bytes);
			Argon2Managed::Blake2b::blake2b_update(blake_state, src);
			out_buffer = Argon2Managed::Blake2b::blake2b_final(blake_state);
			Buffer::BlockCopy(out_buffer, 0, output, outptr, BLAKE2B_OUTBYTES / 2);
			outptr += BLAKE2B_OUTBYTES / 2;
			while (toproduce > BLAKE2B_OUTBYTES) {
				Buffer::BlockCopy(out_buffer, 0, in_buffer, 0, BLAKE2B_OUTBYTES);
				b->Init(BLAKE2B_OUTBYTES);
				out_buffer = b->ComputeHash((array<const Byte>^)in_buffer);
				Buffer::BlockCopy(out_buffer, 0, output, outptr, BLAKE2B_OUTBYTES / 2);
				outptr += BLAKE2B_OUTBYTES / 2;
				toproduce -= BLAKE2B_OUTBYTES / 2;
			}
			Buffer::BlockCopy(out_buffer, 0, in_buffer, 0, BLAKE2B_OUTBYTES);
			b->Init(BLAKE2B_OUTBYTES);
			out_buffer = b->ComputeHash((array<const Byte>^)in_buffer);
			Buffer::BlockCopy(out_buffer, 0, output, outptr, toproduce);
			delete b;
			secure_wipe_memory(in_buffer);
			secure_wipe_memory(out_buffer);
		}
		blake_state->Clear();
		Threading::Thread::MemoryBarrier();
		blake_state = nullptr;
		return output;
	}

	/*
	* Hashes all the inputs into @a blockhash[PREHASH_DIGEST_LENGTH], clears
	* password and secret if needed
	* @param  context  Pointer to the Argon2 internal structure containing memory
	* pointer, and parameters for time and space requirements.
	* @param  blockhash Buffer for pre-hashing digest
	* @param  type Argon2 type
	* @pre    @a blockhash must have at least @a PREHASH_DIGEST_LENGTH bytes
	* allocated
	*/
	static array<Byte>^ initial_hash(Context^ context)
	{
		Blake2bState^ BlakeHash;
		array<Byte>^ value;

		if (nullptr == context) {
			return nullptr;
		}

		BlakeHash = Argon2Managed::Blake2b::blake2b_init(nullptr, nullptr, nullptr, ARGON2_PREHASH_DIGEST_LENGTH);
		
		value = BitConverter::GetBytes(context->lanes);//store32(&value, context->lanes);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);

		value = BitConverter::GetBytes(context->outlen); // store32(&value, context->outlen);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);

		value = BitConverter::GetBytes(context->m_cost); // store32(&value, context->m_cost);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);

		value = BitConverter::GetBytes(context->t_cost); //store32(&value, context->t_cost);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);

		value = BitConverter::GetBytes(context->version); // store32(&value, context->version);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);

		value = BitConverter::GetBytes((UInt32)context->type); // store32(&value, (uint32_t)type);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);

		value = BitConverter::GetBytes(context->pwd->Length); // store32(&value, context->pwdlen);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);

		if (context->pwd != nullptr) {
			Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)context->pwd);
			if (context->flags & ARGON2_FLAG_CLEAR_PASSWORD) {
				secure_wipe_memory(context->pwd);
			}
		}
		// salt should never be null
		value = BitConverter::GetBytes(context->salt->Length);// store32(&value, context->saltlen);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);

		if (context->salt != nullptr) {
			Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)context->salt);
		}
		//secret can be null, but the length must still be recorded
		value = context->secret == nullptr ?
			gcnew array<Byte>(4) : 
			BitConverter::GetBytes(context->secret->Length);// store32(&value, context->secretlen);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);
		if (context->secret != nullptr) {		
			Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)context->secret);
			if (context->flags & ARGON2_FLAG_CLEAR_SECRET) {
				secure_wipe_memory(context->secret);
			}
		}
		// ad can be null, but the length must still be recorded
		value = context->ad == nullptr ?
			gcnew array<Byte>(4) :
			BitConverter::GetBytes(context->ad->Length);// store32(&value, context->adlen);
		Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)value);
		if (context->ad != nullptr) {		
			Argon2Managed::Blake2b::blake2b_update(BlakeHash, (array<const Byte>^)context->ad);
		}
		//System::Diagnostics::Debug::Print(BitConverter::ToString(BlakeHash->Buffer)->Replace("-", ",0x")->ToLower());
		return Argon2Managed::Blake2b::blake2b_final(BlakeHash);
	}

	/*
	* Function allocates memory, hashes the inputs with Blake,  and creates first
	* two blocks. Returns the pointer to the main memory with 2 blocks per lane
	* initialized
	* @param  context  Pointer to the Argon2 internal structure containing memory
	* pointer, and parameters for time and space requirements.
	* @param  instance Current Argon2 instance
	* @return Zero if successful, -1 if memory failed to allocate. @context->state
	* will be modified if successful.
	*/
	static int initialize(Instance^ instance)
	{
		array<Byte>^ blockhash = gcnew array<Byte>(ARGON2_PREHASH_SEED_LENGTH);
		int result = ARGON2_OK;

		if (instance == nullptr || instance->context_ptr == nullptr)
			return ARGON2_INCORRECT_PARAMETER;

		/* 1. Memory allocation */
		Int64 memory_size = instance->memory_blocks * ARGON2_BLOCK_SIZE;

		/* 1.1. Check for multiplication overflow */
		if (instance->memory_blocks != 0 && memory_size / instance->memory_blocks != ARGON2_BLOCK_SIZE) {
			return ARGON2_MEMORY_ALLOCATION_ERROR;
		}

		/* 1.2. Try to allocate */
		instance->memory = gcnew array<block^>(instance->memory_blocks);
		for (Int64 i = 0; i < instance->memory->LongLength; i++)
		{
			instance->memory[i] = gcnew block();
			if (instance->memory[i]->v == nullptr)
				return ARGON2_MEMORY_ALLOCATION_ERROR;
		}

		if (instance->memory == nullptr) {
			return ARGON2_MEMORY_ALLOCATION_ERROR;
		}
		
		/* 2. Initial hashing */
		/* H_0 + 8 extra bytes to produce the first blocks */
		/* Hashing all inputs */
		//array<Byte>^ ih = initial_hash(instance->context_ptr);
		//System::Diagnostics::Debug::Print(BitConverter::ToString(ih)->Replace("-", " ")->ToLower());
		// Initial Hash method returns 64 bytes, the buffer itself is 8 bytes larger, so copy it in
		Buffer::BlockCopy(initial_hash(instance->context_ptr), 0, blockhash, 0, 64); 

		/* 3. Creating first blocks, we always have at least two blocks in a slice	*/
			/* Make the first and second block in each lane as G(H0||0||i) or
			G(H0||1||i) */
		array<Byte>^ blockhash_bytes = gcnew array<Byte>(ARGON2_BLOCK_SIZE);
		for (UInt32 l = 0; l < instance->lanes; l++) {
			//store 4 bytes of LANE into the end of the seed digest buffer
			Buffer::BlockCopy(BitConverter::GetBytes((UInt32)0), 0, blockhash, ARGON2_PREHASH_DIGEST_LENGTH, 4);
			Buffer::BlockCopy(BitConverter::GetBytes(l), 0, blockhash, ARGON2_PREHASH_DIGEST_LENGTH + 4, 4);
			blockhash_bytes = blake2b_long(ARGON2_BLOCK_SIZE, (array<const Byte>^)blockhash);
			Buffer::BlockCopy(blockhash_bytes, 0, (instance->memory[l * instance->lane_length]->v), 0, blockhash_bytes->Length);

			blockhash[ARGON2_PREHASH_DIGEST_LENGTH] = (Byte)1; // block hash still has LANE, now set the 1 in H0||1||i
			blockhash_bytes = blake2b_long(ARGON2_BLOCK_SIZE, (array<const Byte>^)blockhash);
			Buffer::BlockCopy(blockhash_bytes, 0, (instance->memory[(l * instance->lane_length) + 1]->v), 0, blockhash_bytes->Length);
		}
		// Clearing the hash, this is to prevent memory sniffing for pre-images to the larger process 
		// The password and (optional) secret are included at this point, so this is mandatory
		secure_wipe_memory(blockhash_bytes);
		secure_wipe_memory(blockhash);
		Threading::Thread::MemoryBarrier();
		return ARGON2_OK;
	}

	/*
	* XORing the last block of each lane, hashing it, making the tag. Deallocates
	* the memory.
	* @param context Pointer to current Argon2 context (use only the out parameters
	* from it)
	* @param instance Pointer to current instance of Argon2
	* @pre instance->state must point to necessary amount of memory
	* @pre context->out must point to outlen bytes of memory
	* @pre if context->free_cbk is not NULL, it should point to a function that
	* deallocates memory
	*/
	static void finalize(Instance^ instance)
	{
		if (instance != nullptr && instance->context_ptr != nullptr )
		{
			block^ blockhash = gcnew block();
			copy_block(blockhash, instance->memory[instance->lane_length - 1]);

			/* XOR the last blocks */
			for (UInt32 l = 1; l < instance->lanes; l++) {
				UInt32 last_block_in_lane =
					l * instance->lane_length + (instance->lane_length - 1);
				xor_block(blockhash, (const block^)instance->memory[last_block_in_lane]);
			}

			/* Hash the result */
			{
				array<Byte>^ blockhash_bytes = gcnew array<Byte>(ARGON2_BLOCK_SIZE);
				Buffer::BlockCopy(blockhash->v, 0, blockhash_bytes, 0, ARGON2_BLOCK_SIZE);
				instance->context_ptr->out = blake2b_long(instance->context_ptr->outlen, (array<const Byte>^)blockhash_bytes);
				/* clear blockhash and blockhash_bytes */
				secure_wipe_memory(blockhash->v);
				secure_wipe_memory(blockhash_bytes);
			}

			free_memory(instance->memory);
		}
	}
	
	/*designed by the Lyra PHC team */
	static __inline UInt64 fBlaMka(UInt64 x, UInt64 y) {
		const UInt64 m = UInt64(0xFFFFFFFF);
		const UInt64 xy = (x & m) * (y & m);
		return x + y + 2 * xy;
	}

#define	ROTR64(w,c) (((UInt64)(w) >> c) | ((UInt64)(w) << (64 - c)))

#define G(a, b, c, d)                                                          \
    do {                                                                       \
        a = fBlaMka(a, b);                                                     \
        d = ROTR64(d ^ a, 32);                                                 \
        c = fBlaMka(c, d);                                                     \
        b = ROTR64(b ^ c, 24);                                                 \
        a = fBlaMka(a, b);                                                     \
        d = ROTR64(d ^ a, 16);                                                 \
        c = fBlaMka(c, d);                                                     \
        b = ROTR64(b ^ c, 63);                                                 \
    } while ((void)0, 0)

#define BLAKE2_ROUND_NOMSG(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,   \
                           v12, v13, v14, v15)                                 \
    do {                                                                       \
        G(v0, v4, v8, v12);                                                    \
        G(v1, v5, v9, v13);                                                    \
        G(v2, v6, v10, v14);                                                   \
        G(v3, v7, v11, v15);                                                   \
        G(v0, v5, v10, v15);                                                   \
        G(v1, v6, v11, v12);                                                   \
        G(v2, v7, v8, v13);                                                    \
        G(v3, v4, v9, v14);                                                    \
    } while ((void)0, 0)

	/*
	* Function fills a new memory block and optionally XORs the old block over the new one.
	* @next_block must be initialized.
	* @param prev_block Pointer to the previous block
	* @param ref_block Pointer to the reference block
	* @param next_block Pointer to the block to be constructed
	* @param with_xor Whether to XOR into the new block (1) or just overwrite (0)
	* @pre all block pointers must be valid
	*/
	static void fill_block(const block^ prev_block, const block^ ref_block, block^ next_block, const bool with_xor)
	{
		block^ blockR = gcnew block();
		block^ block_tmp = gcnew block();

		copy_block(blockR, (const block^)ref_block);
		xor_block(blockR, (const block^)prev_block);
		copy_block(block_tmp, (const block^)blockR);
		/* Now blockR = ref_block + prev_block and block_tmp = ref_block + prev_block */
		if (with_xor) {
			/* Saving the next block contents for XOR over: */
			xor_block(block_tmp, (const block^)next_block);
			/* Now blockR = ref_block + prev_block and block_tmp = ref_block + prev_block + next_block */
		}
//VERIFIED WORKING BELOW THIS LINE
		/* Apply Blake2 on columns of 64-bit words: (0,1,...,15) , then
		(16,17,..31)... finally (112,113,...127) */
		for (Byte i = 0; i < 8; ++i) {
			BLAKE2_ROUND_NOMSG(
				blockR->v[16 * i], blockR->v[16 * i + 1], blockR->v[16 * i + 2],
				blockR->v[16 * i + 3], blockR->v[16 * i + 4], blockR->v[16 * i + 5],
				blockR->v[16 * i + 6], blockR->v[16 * i + 7], blockR->v[16 * i + 8],
				blockR->v[16 * i + 9], blockR->v[16 * i + 10], blockR->v[16 * i + 11],
				blockR->v[16 * i + 12], blockR->v[16 * i + 13], blockR->v[16 * i + 14],
				blockR->v[16 * i + 15]);
		}

		/* Apply Blake2 on rows of 64-bit words: (0,1,16,17,...112,113), then
		(2,3,18,19,...,114,115).. finally (14,15,30,31,...,126,127) */
		for (Byte i = 0; i < 8; i++) {
			BLAKE2_ROUND_NOMSG(
				blockR->v[2 * i], blockR->v[2 * i + 1], blockR->v[2 * i + 16],
				blockR->v[2 * i + 17], blockR->v[2 * i + 32], blockR->v[2 * i + 33],
				blockR->v[2 * i + 48], blockR->v[2 * i + 49], blockR->v[2 * i + 64],
				blockR->v[2 * i + 65], blockR->v[2 * i + 80], blockR->v[2 * i + 81],
				blockR->v[2 * i + 96], blockR->v[2 * i + 97], blockR->v[2 * i + 112],
				blockR->v[2 * i + 113]);
		}
//VERIFIED WORKING ABOVE THIS LINE
		copy_block(next_block, (const block^)block_tmp);
		xor_block(next_block, (const block^)blockR);
	}

	/*
	* Function that fills the segment using previous segments also from other
	* threads
	* @param context current context
	* @param instance Pointer to the current instance
	* @param position Current position
	* @pre all block pointers must be valid
	*/
	static void fill_segment(const Instance^ instance,
		Position^ position)
	{
		block^ ref_block;
		block^ curr_block;
		block^ address_block = gcnew block();
		block^ input_block = gcnew block();
		block^ zero_block = gcnew block();
		UInt64 pseudo_rand, ref_index, ref_lane;
		UInt32 prev_offset, curr_offset;
		UInt32 starting_index;
		UInt32 i;
		int data_independent_addressing;

		if (instance == nullptr) {
			return;
		}

		data_independent_addressing =
			(instance->context_ptr->type == Argon2Managed::Argon2Type::i) ||
			(instance->context_ptr->type == Argon2Managed::Argon2Type::id && (position->pass == 0) &&
			(position->slice < ARGON2_SYNC_POINTS / 2));

		if (data_independent_addressing) {
			//init_block_value(input_block, 0); gcnew zero's the block for us
			input_block->v[0] = position->pass;
			input_block->v[1] = position->lane;
			input_block->v[2] = position->slice;
			input_block->v[3] = instance->memory_blocks;
			input_block->v[4] = instance->passes;
			input_block->v[5] = (UInt64)instance->context_ptr->type;
		}

		starting_index = 0;
		if ((0 == position->pass) && (0 == position->slice)) {
			starting_index = 2; /* we have already generated the first two blocks */

			/* Don't forget to generate the first block of addresses: */
			/* The Zero block is never written to */
			if (data_independent_addressing) {
				input_block->v[6]++;
				fill_block((const block^)zero_block, (const block^)input_block, address_block, 0);
				fill_block((const block^)zero_block, (const block^)address_block, address_block, 0);
			}
		}

		/* Offset of the current block */
		curr_offset = position->lane * instance->lane_length +
			position->slice * instance->segment_length + starting_index;

		if (0 == curr_offset % instance->lane_length) {
			/* Last block in this lane */
			prev_offset = curr_offset + instance->lane_length - 1;
		}
		else {
			/* Previous block */
			prev_offset = curr_offset - 1;
		}

		//System::Diagnostics::Debug::Print("About to enter for loop...");
		for (i = starting_index; i < instance->segment_length;
			i++, curr_offset++, prev_offset++) 
		{
			//System::Diagnostics::Debug::Print("i < instance->segment_length, i=" + i);
			/*1.1 Rotating prev_offset if needed */
			if (curr_offset % instance->lane_length == 1) {
				prev_offset = curr_offset - 1;
			}

			/* 1.2 Computing the index of the reference block */
			/* 1.2.1 Taking pseudo-random value from the previous block */
			if (data_independent_addressing) {
				if (i % ARGON2_ADDRESSES_IN_BLOCK == 0) {
					input_block->v[6]++;
					fill_block((const block^)zero_block, (const block^)input_block, address_block, 0);
					fill_block((const block^)zero_block, (const block^)address_block, address_block, 0);
				}
				pseudo_rand = address_block->v[i % ARGON2_ADDRESSES_IN_BLOCK];
			}
			else {
				pseudo_rand = instance->memory[prev_offset]->v[0]; // this is a single UInt64
			}

			/* 1.2.2 Computing the lane of the reference block */
			ref_lane = ((pseudo_rand >> 32)) % instance->lanes;

			if ((position->pass == 0) && (position->slice == 0)) {
				/* Can not reference other lanes yet */
				ref_lane = position->lane;
			}

			/* 1.2.3 Computing the number of possible reference block within the
			* lane.
			*/
			position->index = i;
			ref_index = index_alpha(instance, position, pseudo_rand & 0xFFFFFFFF,
				ref_lane == position->lane);


			/* 2 Creating a new block */
			ref_block =
				instance->memory[instance->lane_length * ref_lane + ref_index];
			curr_block = instance->memory[curr_offset];
			if (ARGON2_VERSION_10 == instance->context_ptr->version) {
				/* version 1.2.1 and earlier: overwrite, not XOR */
				fill_block(instance->memory[prev_offset], ref_block, curr_block, 0);
			}
			else {
				fill_block(instance->memory[prev_offset], ref_block, curr_block, 
					position->pass == 0 ? false : true);
			}
		}
	}

	static int fill_memory_blocks_st(Instance^ instance) {
		UInt32 r, s, l;

		for (r = 0; r < instance->passes; r++) 
		{
			//System::Diagnostics::Debug::Print("FILL_MEMORY_BLOCKS, R=" + r);
			for (s = 0; s < ARGON2_SYNC_POINTS; s++) 
			{
				//System::Diagnostics::Debug::Print("FILL_MEMORY_BLOCKS, S=" + s);
				for (l = 0; l < instance->lanes; l++) 
				{
					//System::Diagnostics::Debug::Print("FILL_MEMORY_BLOCKS, L=" + l);
					Position^ position = gcnew Position;
					position->pass = r;
					position->lane = l;
					position->slice = (Byte)s;
					position->index = 0;
					fill_segment(instance, position);
				}
			}
		}
		return ARGON2_OK;
	}

	/*
	* Function that fills the entire memory t_cost times based on the first two
	* blocks in each lane
	* @param instance Pointer to the current instance
	* @return ARGON2_OK if successful, @context->state
	*/
	static int fill_memory_blocks(Instance^ instance)
	{
		if (instance == nullptr || instance->lanes == 0) {
			return ARGON2_INCORRECT_PARAMETER;
		}
		// WARNING!  ISSUE WITH MULTI THREAD IMPLEMENTATION***********
		return //instance->threads == 1 ?
			fill_memory_blocks_st(instance);// : fill_memory_blocks_mt(instance);
	}

	static int decode_string(String^ data, Context^ ctx)
	{
		array<Byte>^ salt = nullptr;
		array<Byte>^ out = nullptr;
		if (data == nullptr || String::IsNullOrWhiteSpace(data))
			return ARGON2_DECODING_FAIL;
		// strings will look like this: "$argon2i$v=19$m=1048576,t=2,p=1$c29tZXNhbHQ$0Vh6ygkiw7XWqD7asxvuPE667zQu1hJ6VdGbI1GtH0E"
		// the version string might be missing, in which case, assume latest
		System::Text::RegularExpressions::Regex^ reg = gcnew System::Text::RegularExpressions::Regex(L"[^$^,^\\s]+");
		System::Text::RegularExpressions::MatchCollection^ parts = reg->Matches(data);
		if (parts->Count != 7 && parts->Count !=6)
			return ARGON2_MISSING_ARGS;
		//parts: 0 = type, 1 = version, 2 = m_cost, 3 = t_cost, 4 = parallelism, 5 = salt (base64), 6 = result (base64)
		//parts: 0 = type, 1 = m_cost, 2 = t_cost, 3 = parallelism, 4 = salt (base64), 5 = result (base64)
		if (parts[0]->Value->ToLower()->CompareTo(L"argon2d") == 0)
			ctx->type = Argon2Type::d;
		else if (parts[0]->Value->ToLower()->CompareTo(L"argon2i") == 0)
			ctx->type = Argon2Type::i;
		else if (parts[0]->Value->ToLower()->CompareTo(L"argon2id") == 0)
			ctx->type = Argon2Type::id;
		else return ARGON2_INCORRECT_TYPE;
		int partsPtr = 1;
		if (parts[1]->Value->StartsWith(L"v="))
		{
			ctx->version = UInt32::Parse(parts[1]->Value->Replace("v=", ""));
			partsPtr++;
		}
		else if (parts[1]->Value->StartsWith("m="))
		{
			ctx->version = ARGON2_VERSION_NUMBER; // assume latest
		}
		else
			return ARGON2_MISSING_ARGS;
		// here, partsPtr will be 1 if the "v=" version string missing, or 2 if present
		if (parts[partsPtr]->Value->StartsWith(L"m="))
			ctx->m_cost = UInt32::Parse(parts[partsPtr++]->Value->Replace("m=", ""));
		else
			return ARGON2_MISSING_ARGS;
		if (parts[partsPtr]->Value->StartsWith(L"t="))
			ctx->t_cost = UInt32::Parse(parts[partsPtr++]->Value->Replace("t=", ""));
		else
			return ARGON2_MISSING_ARGS;
		if (parts[partsPtr]->Value->StartsWith(L"p="))
			ctx->lanes = UInt32::Parse(parts[partsPtr++]->Value->Replace("p=", ""));
		else
			return ARGON2_MISSING_ARGS;
		try {
			String^ stuff = parts[partsPtr++]->Value;
			if (stuff->Length % 4 != 0)
				stuff += gcnew String('=', 4 - stuff->Length % 4);
			salt = Convert::FromBase64String(stuff);
			stuff = parts[partsPtr]->Value;
			if (stuff->Length % 4 != 0)
				stuff += gcnew String('=', 4 - stuff->Length % 4);
			out = Convert::FromBase64String(stuff);
		}
		catch (const System::Exception^ ex) {}
		if (salt == nullptr)
			return ARGON2_SALT_PTR_MISMATCH;
		if (out == nullptr)
			return ARGON2_OUT_PTR_MISMATCH;
		ctx->out = out;
		ctx->outlen = out->Length;
		ctx->salt = salt;
		// check everything	
		int validation_result = validate_inputs(ctx);

		return validation_result;

	}

	static String^ encode_string(Context^ ctx)
	{
		String^ type_string;
		switch (ctx->type)
		{
		case Argon2Type::d:		type_string = "argon2d";	break;
		case Argon2Type::i:		type_string = "argon2i";	break;
		case Argon2Type::id:	type_string = "argon2id";	break;
		}
		return String::Format("${0}$v={1}$m={2},t={3},p={4}${5}${6}",
			type_string,
			ctx->version,
			ctx->m_cost,
			ctx->t_cost,
			ctx->lanes,
			System::Convert::ToBase64String(ctx->salt)->Replace("=", ""),
			System::Convert::ToBase64String(ctx->out)->Replace("=", "")
		);
	}

	static int argon2_compare(array<const Byte>^ b1, array<const Byte>^ b2 ) {
		Byte d = 0U;
		int len = Math::Min(b2->Length, b1->Length);
		for (int i = 0U; i < len; i++) {
			d |= b1[i] ^ b2[i];
		}
		return (int)((1 & ((d - 1) >> 8)) - 1);
	}
}
