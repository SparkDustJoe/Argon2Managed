#pragma once

/*
* Adapted from the reference code implementation
*   Copyright 2017-2019 Dustin J Sparks
*   Using CC0 1.0 license, this code is released under the same.
* ===========================================================================
* Argon2 reference source code package - reference C implementations
*
* Copyright 2015
* Daniel Dinu, Dmitry Khovratovich, Jean-Philippe Aumasson, and Samuel Neves
*
* You may use this work under the terms of a Creative Commons CC0 1.0
* License/Waiver or the Apache Public License 2.0, at your option. The terms of
* these licenses can be found at:
*
* - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
* - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
*
* You should have received a copy of both of these licenses along with this
* software. If not, they may be obtained at the above URLs.
*/

#include "Argon2Managed.h"

#define ARGON2_VERSION_10		0x10
#define ARGON2_VERSION_13		0x13
#define ARGON2_VERSION_NUMBER	ARGON2_VERSION_13

#define T_COST_DEF		3
#define M_COST_DEF		4096 /* 2^12 = 4 MiB */
#define LANES_DEF		1
#define THREADS_DEF		1
#define OUTLEN_DEF		32
//#define MAX_PASS_LEN	128

#define ARGON2_BLOCK_SIZE				1024
#define ARGON2_QWORDS_IN_BLOCK			(ARGON2_BLOCK_SIZE / 8)
#define ARGON2_OWORDS_IN_BLOCK			(ARGON2_BLOCK_SIZE / 16)
#define ARGON2_HWORDS_IN_BLOCK			(ARGON2_BLOCK_SIZE / 32)
#define ARGON2_512BIT_WORDS_IN_BLOCK	(ARGON2_BLOCK_SIZE / 64)

/* Number of pseudo-random values generated by one call to Blake in Argon2i
to generate reference block positions */
#define ARGON2_ADDRESSES_IN_BLOCK		128

/* Pre-hashing digest length and its extension*/
#define ARGON2_PREHASH_DIGEST_LENGTH	64
#define ARGON2_PREHASH_SEED_LENGTH		72
/* Minimum and maximum number of lanes (degree of parallelism) */
#define ARGON2_MIN_LANES 1UL
#define ARGON2_MAX_LANES 0xFFFFFFUL

/* Minimum and maximum number of threads */
#define ARGON2_MIN_THREADS 1UL
#define ARGON2_MAX_THREADS 0xFFFFFFUL

/* Number of synchronization points between lanes per pass */
#define ARGON2_SYNC_POINTS 4UL

/* Minimum and maximum digest size in bytes */
#define ARGON2_MIN_OUTLEN 4UL
#define ARGON2_MAX_OUTLEN 0xFFFFFFFFUL

/* Minimum and maximum number of memory blocks (each of BLOCK_SIZE bytes) */
#define ARGON2_MIN_MEMORY (2 * ARGON2_SYNC_POINTS) /* 2 blocks per slice */

#define ARGON2_MIN(a, b) ((a) < (b) ? (a) : (b))
/* Max memory size is addressing-space/2, topping at 2^32 blocks (4 TB) */
#define ARGON2_MAX_MEMORY                                                      \
    ARGON2_MIN(0xFFFFFFFFUL, 1UL << ARGON2_MAX_MEMORY_BITS)

/* Minimum and maximum number of passes */
#define ARGON2_MIN_TIME 1UL
#define ARGON2_MAX_TIME 0xFFFFFFFFUL

/* Minimum and maximum password length in bytes */
#define ARGON2_MIN_PWD_LENGTH 0
#define ARGON2_MAX_PWD_LENGTH 0xFFFFFFFFUL

/* Minimum and maximum associated data length in bytes */
#define ARGON2_MIN_AD_LENGTH 0
#define ARGON2_MAX_AD_LENGTH 0xFFFFFFFFUL

/* Minimum and maximum salt length in bytes */
#define ARGON2_MIN_SALT_LENGTH 8UL
#define ARGON2_MAX_SALT_LENGTH 0xFFFFFFFFUL

/* Minimum and maximum key length in bytes */
#define ARGON2_MIN_SECRET 0
#define ARGON2_MAX_SECRET 0xFFFFFFFFUL

/* Flags to determine which fields are securely wiped (default = wipe all). */
#define ARGON2_DEFAULT_FLAGS		3
#define ARGON2_FLAG_CLEAR_PASSWORD	1UL
#define ARGON2_FLAG_CLEAR_SECRET	2UL

namespace Argon2Managed
{
	int Argon2::ComputeHash(array<const Byte>^ password, array<const Byte>^ salt,
		const UInt32 outputLengthBytes,
		const Argon2Type type,
		const UInt32 timeCost, const UInt32 memoryKb, const UInt32 lanes,
		array<Byte>^% output)
	{
		array<Byte>^ stuff = gcnew array<Byte>(outputLengthBytes);
		Context^ ctx = gcnew Context();
		int ret = argon2_hash(password, salt, outputLengthBytes, type, nullptr, nullptr, timeCost, memoryKb, lanes, stuff, ctx);
		if (ret == ARGON2_OK) output = stuff; // 0 = ok
		return ret;
	}

	int Argon2::ComputeEncodedHash(array<const Byte>^ password, array<const Byte>^ salt,
		const UInt32 outputLengthBytes,
		const Argon2Type type,
		const UInt32 timeCost, const UInt32 memoryKb, const UInt32 lanes,
		array<Byte>^% output, String^% encodedOutput)
	{
		array<Byte>^ stuff = gcnew array<Byte>(outputLengthBytes);
		Context^ ctx;
		int ret = argon2_hash(password, salt, outputLengthBytes, type, nullptr, nullptr, timeCost, memoryKb, lanes, stuff, ctx);
		if (ret == ARGON2_OK) {
			output = stuff;
			encodedOutput = encode_string(ctx);
		}
		return ret;
	}

	int Argon2::ComputeHash(array<const Byte>^ password, array<const Byte>^ salt,
		const UInt32 outputLengthBytes,
		const Argon2Type type,
		array<const Byte>^ secret,
		array<const Byte>^ additionalData,
		const UInt32 timeCost, const UInt32 memoryKb, const UInt32 lanes,
		array<Byte>^% output)
	{
		array<Byte>^ stuff = gcnew array<Byte>(outputLengthBytes);
		Context^ ctx = gcnew Context();
		int ret = argon2_hash(password, salt, outputLengthBytes, type, secret, additionalData, timeCost, memoryKb, lanes, stuff, ctx);
		if (ret == ARGON2_OK) output = stuff;
		return ret;
	}

	int Argon2::ComputeEncodedHash(array<const Byte>^ password, array<const Byte>^ salt,
		const UInt32 outputLengthBytes,
		const Argon2Type type,
		array<const Byte>^ secret,
		array<const Byte>^ additionalData,
		const UInt32 timeCost, const UInt32 memoryKb, const UInt32 lanes,
		array<Byte>^% output, String^% encodedOutput)
	{
		array<Byte>^ stuff = gcnew array<Byte>(outputLengthBytes);
		Context^ ctx = gcnew Context();
		int ret = argon2_hash(password, salt, outputLengthBytes, type, secret, additionalData, timeCost, memoryKb, lanes, stuff, ctx);
		if (ret == ARGON2_OK) {
			output = stuff;
			encodedOutput = encode_string(ctx);
		}
		return ret;
	}

	int Argon2::VerifyEncodedHash(array<const Byte>^ password, const String^ encodedData)
	{
		return VerifyEncodedHash(password, nullptr, nullptr, encodedData);
	}
	
	int Argon2::VerifyEncodedHash(array<const Byte>^ password, array<const Byte>^ secret, array<const Byte>^ additionalData, const String^ encodedData)
	{
		Context^ ctx = gcnew Context();
		ctx->pwd = (array<Byte>^)password;
		ctx->secret = (array<Byte>^)secret;
		ctx->ad = (array<Byte>^)additionalData;
		ctx->threads = THREADS_DEF;
		if (encodedData == nullptr)
			return ARGON2_DECODING_LENGTH_FAIL;
		int ret = decode_string((String^)encodedData, ctx);
		if (ret != ARGON2_OK)
			return ret;
		array<Byte>^ compareMe = gcnew array<Byte>(ctx->out->Length);
		ret = Argon2::argon2_hash(
			password, (array<const Byte>^)ctx->salt, 
			(const UInt32)ctx->out->Length, ctx->type, 
			secret, additionalData, 
			(const UInt32)ctx->t_cost, (const UInt32)ctx->m_cost, (const UInt32)ctx->lanes, 
			compareMe, ctx);
		if (ret != ARGON2_OK)
			return ret;
		if (argon2_compare((array<const Byte>^)compareMe, (array<const Byte>^)ctx->out) != 0)
			return ARGON2_VERIFY_MISMATCH;
		return ARGON2_OK;
	}

	int Argon2::argon2_hash(
		array<const Byte>^ password, array<const Byte>^ salt, const UInt32 outputLengthBytes,
		const Argon2Type type,
		array<const Byte>^ secret,
		array<const Byte>^ additionalData,
		const UInt32 timeCost, const UInt32 memoryKb, const UInt32 lanes,
		array<Byte>^ output, Context^% ctx)
	{
		ctx = gcnew Context();
		ctx->ad = (array<Byte>^)additionalData;
		ctx->secret = (array<Byte>^)secret;
		ctx->salt = (array<Byte>^)salt;
		ctx->pwd = (array<Byte>^)password;
		ctx->lanes = lanes;
		ctx->threads = THREADS_DEF;
		ctx->t_cost = timeCost;
		ctx->m_cost = memoryKb;
		ctx->outlen = outputLengthBytes;
		ctx->version = ARGON2_VERSION_13; // assume latest
		ctx->type = type;
		ctx->out = output;

		Instance^ instance = gcnew Instance();
		/* 1. Validate all inputs */
		int result = validate_inputs(ctx);
		UInt32 memory_blocks, segment_length;

		if (ARGON2_OK != result) {
			return result;
		}

		if (Argon2Type::i != type && Argon2Type::d != type && Argon2Type::id != type) {
			return ARGON2_INCORRECT_TYPE;
		}

		/* 2. Align memory size */
		/* Minimum memory_blocks = 8L blocks, where L is the number of lanes */
		memory_blocks = ctx->m_cost;

		if (memory_blocks < 2 * ARGON2_SYNC_POINTS * ctx->lanes) {
			memory_blocks = 2 * ARGON2_SYNC_POINTS * ctx->lanes;
		}

		segment_length = memory_blocks / (ctx->lanes * ARGON2_SYNC_POINTS);
		/* Ensure that all segments have equal length */
		memory_blocks = segment_length * (ctx->lanes * ARGON2_SYNC_POINTS);

		instance->context_ptr = ctx;
		instance->memory = nullptr;
		instance->passes = ctx->t_cost;
		instance->memory_blocks = memory_blocks;
		instance->segment_length = segment_length;
		instance->lane_length = segment_length * ARGON2_SYNC_POINTS;
		instance->lanes = ctx->lanes;
		instance->threads = ctx->threads;

		if (instance->threads > instance->lanes) {
			instance->threads = instance->lanes;
		}

		/* 3. Initialization: Hashing inputs, allocating memory, filling first
		* blocks
		*/
		result = initialize(instance);

		if (ARGON2_OK != result) {
			return result;
		}

		/* 4. Filling memory */
		result = fill_memory_blocks(instance);

		if (ARGON2_OK != result) {
			return result;
		}
		/* 5. Finalization */
		finalize(instance);
		Buffer::BlockCopy(ctx->out, 0, output, 0, ctx->outlen);
		return ARGON2_OK;
	}
}